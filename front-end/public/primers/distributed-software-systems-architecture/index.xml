<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Distributed Software Systems Architecture on CYF&#43;</title>
    <link>/primers/distributed-software-systems-architecture/</link>
    <description>Recent content in Distributed Software Systems Architecture on CYF&#43;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/primers/distributed-software-systems-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Reliable RPCs</title>
      <link>/primers/distributed-software-systems-architecture/reliable-rpcs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/primers/distributed-software-systems-architecture/reliable-rpcs/</guid>
      <description>1 Reliable RPCs About Remote Procedure Calls (RPCs) The Remote Procedure Call is the fundamental building block of distributed systems: they are how you can run a procedure - i.e. a piece of code - on another machine. Without RPCs we cannot build an efficient distributed system: they are essential to the existence of GMail, Netflix, Spotify, Facebook, and all other large-scale distributed software systems. Keeping RPCs flowing reliably is a significant part of most infrastructure engineering jobs.</description>
    </item>
    
    <item>
      <title>2. State</title>
      <link>/primers/distributed-software-systems-architecture/state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/primers/distributed-software-systems-architecture/state/</guid>
      <description>2 State Stateful and stateless
Components in distributed systems are often divided into stateful and stateless services. Stateless services don’t store any state between serving requests. Stateful services, such as databases and caches, do store state between requests. State stays.
When we need to scale up a stateless service we simply run more instances and loadbalance between them. Scaling up a stateful service is different: we need to deal with splitting up or replicating our data, and keeping things in sync.</description>
    </item>
    
    <item>
      <title>3. Scaling Stateless Services</title>
      <link>/primers/distributed-software-systems-architecture/scaling-stateless-services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/primers/distributed-software-systems-architecture/scaling-stateless-services/</guid>
      <description>3 Scaling Stateless Services Microservices or monoliths A monolith is a single large program that encapsulates all the logic for your application. A microservice architecture, on the other hand, splits application functionality across a number of smaller programs, which are composed together to form your application. Both have advantages and drawbacks. ​​
Read Microservices versus Monoliths for a discussion of microservices and monoliths. Optionally, watch - a comedy about the extremes of microservice-based architectures.</description>
    </item>
    
    <item>
      <title>4. Asynchronous Work and Pipelines</title>
      <link>/primers/distributed-software-systems-architecture/asynchronous-work-and-pipelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/primers/distributed-software-systems-architecture/asynchronous-work-and-pipelines/</guid>
      <description>4 Asynchronous Work and Pipelines Not all work that we want to do with computers involves serving a request in near-real-time and responding to a user. Sometimes we need to do asynchronous tasks like:
Periodic work, such as a nightly data export, or computing monthly reports Work scheduled for later, such as scheduling reminders to users Long-running work, such as scheduling a build or a set of tests Running a continuous statistics computation based on incoming data Batch processes may not be that large and may just run as a scheduled cron job.</description>
    </item>
    
    <item>
      <title>5. Distributed Locking and Distributed Consensus</title>
      <link>/primers/distributed-software-systems-architecture/distributed-locking-and-distributed-consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/primers/distributed-software-systems-architecture/distributed-locking-and-distributed-consensus/</guid>
      <description>5 Distributed Locking and Distributed Consensus In a program, sometimes we need to lock a resource. Think about a physical device, like a printer: we only want one program to print at a time. Locking applies to lots of other kinds of resources too, often when we need to update multiple pieces of data in consistent ways in a multi-threaded context.
How to do distributed locking We need to be able to do locking in distributed systems as well.</description>
    </item>
    
  </channel>
</rss>
